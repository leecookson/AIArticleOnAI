# How AI Tools Work (and don't work)

We are solidly in the age of AI helpers being part of solving technology problems. The only question left is which problems can they effectively solve, and which models are good at solving different kinds of problems.

First, there are a LOT of problems to solve. And they widely vary from routine issues with coding, to designing large, inter-related systems that have to work with large amounts of diverse data. The first wave of AI tools solved the problem of writing moderate amounts of code that implemented fairly self-contained requirements. Guessing what you need to type next, implementing an algorithm the coder can describe, and re-formatting code to modernize it or make it follow a style guide are all on the lower rungs of the AI helper ladder.

Which language you use probably isn't a big issue for this area. As long as there's a big enough pool of examples, any helper will do this as a starting point. The first step into discriminating between tools is relatively narrow use-cases. Personally, I lean heavily into cloud engineering, and deploying resources to AWS, Azure and Google Cloud, so Terraform becomes a common starting point for solving problems and setting up new systems. Terraform itself is ubiquitous, and as a language (HCL) it's very simple, so formatting and understanding how to write a template is in the "extremely easy" category. Where things get tricky is when you ask a helper to create a template for a specific set of resources that need to work together. One example is setting up the permissions, typically referred to under the umbrella term Identity and Access Management, or IAM for short. To create a new database or web site, you need permission to do it first. The various providers use similar concepts, but each implements them differently. As an AI helper, it needs a large enough body of knowledge, including the documentation for the platforms, to understand and generate a template for your specific needs.

A prompt to create an identity provider in each platform will generally result in a decent starting point. Asking to create an OIDC connection with a specific deployment platform like GitHub Actions, CircleCI or GitLab might be fine…or might give you a huge mess of a template you need to unwrap and get working properly. For example, an AWS connector with CircleCI wasn't too hard to code, but after many prompts and a few adjustments, I realized there was a publically available Terraform module that solved the problem with about 8 lines of code. AWS, done.

Then on to Google Cloud (GCP). Similar experience, though the raw Terraform code was a bit messier, it stil worked, but I took the shortcut to another re-usable module; 8 lines and done. Ironically, while trying to create a static web site on GCP, using a simple static website using a CDN approach, the resources were extremely messy to connect to each other, and Google's own Gemini (2.5 Pro) struggled to make sense of the issue and to generate useful code. ChatGPT even suggested I use a resource named google_certificate_manager_target_https_proxy to solve a problem using specific kinds of certificates with google_compute_target_https_proxy, which is clearly a halucination since it doesn't exist, or make any sense at all.

Now, for the finale, getting Azure to work with CircleCI was a major challenge. All the AI models I tried gave me a "valid" but unusable set of resources for integrating a deployment pipeline using OIDC. Part of the challenge was the fairly small user space where Azure and CircleCI cross. No easy-to-use Terraform module, and all proposed solutions drove right into "generate static credentials" mode, which I was determined to avoid. In the end, I did come up with a solution, but the AI tools were only able to suggest small, incremental changes, or translate an Azure command-line I needed into a Terraform resource. The root issues were both with how Azure manages "ownership" when a deploy occurs, and the rigid OIDC subject mapping. For the ownership issue, to avoid constant flapping back and forth when I wan a plan locally and in CircleCI, I had to code my owner ID (not a secret) into the template, so CircleCI wouldn't keep re-assigning ownership to the deployer's service account. To solve the issue with the OIDC subject matching, I couldn't use the preview "Match Expression" feature since it both wasn't implemented in the Terraform provider, and Microsoft doesn't support CircleCI for this feature yet. GitHub, GitLab and Terraform Cloud are supported, so it's not a generic match feature at all. The solution here was to deploy a separate Federated Credential for each CircleCI project, which meant each time I add a project (a decent real-world way to encapsulate and separate individual projects), I need to add it's ID to the Terraform configuration so it has permission to deploy resources.

My chosen triple-platform use-case may seem contrived, but it gave me a good view of the different approaches each platform use to manage permissions and integrations with CI/CD platforms. It also demonstrated how much community support there is for each platform and how well the AI helpers can guide you on your journey.

In general, the AWS solutions were stable, various tools provided similar solutions, and they made sense, partly due to AWS's simpler approach to certain use-cases, but also because there are so many engineers working on integrating AWS with the many CI/CD platforms. GCP was a challenge setting up a simple static web site, but there were some decent support from the Terraform community for some areas, even if Gemini came up short. Azure seems to be the odd one out, but I found that the integrated CoPilot did reasonably well solving problems while I was troubleshooting in the console. That points to one issue with the overall scheme: If you have to spend lots of time in the console, the resource model, and the Terraform knowledge base for it, are either too esoteric to have a critical mass of content, or the platform itself is too hard to figure out, even for AI tools.

# Conclusion

All the tools I used did a good job at creating and refining narrow parts of the solutions I sought. None were particularly great at creating big-picture, cross-platform solutions.

Of note, and since I was very familiar with the desired outcome, Asking Gemini to create a full configuration for an AWS CloudFront site, including certificates, S3 content storage and logs was almost a first-time exact match. I did wind up refining the result slightly, but this was purely refinement, and not "fixing". Since CloudFront encapsulates almost all of the configuration into a single resource, there is likely a lot of off-the-shelf examples for an AI tool to "borrow", compared with the dozen-or-more resources Azure and GCP use to build a simple site.

# Epilogue

I made some assumptions and set some baseline requirements for this project:

- Solve similar problems across all 3 platforms. Primary was a simple static web site using the normal commodity file storage mechanism.
- Use a "best practice" approach for both local and CI/CD platform authentication and permissions. Rather than just creating secret keys and dropping them into a dot file, or adding to the deployment job's secret store, I wanted to use modern, secret-free approaches where it made sense. For local dev, I used a 1Password plugin with AWS, and Azure and GCP have a very easy-to-use web-based auth approach. For CI/CD, I wanted to use OIDC, period.
- Use a variety of tools, including Gemini, ChatGPT, Azure's CoPilot, CircleCI's AI helper, and a little bit of GitHub CoPilot. I often threw the same prompt at 2–3 of them to see which gave a more complete or usable respons.
